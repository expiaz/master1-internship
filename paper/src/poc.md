```{=latex}
\clearpage
```

# Travail réalisé

## Scan

Le *scan* des appareils et *sniffing* des connexions BLE alentours se base sur un sniffer BLE, la carte `micro:bit` dans mon cas. Les fonctionnalités de scan sont nativement supportée par Mirage et intégrées dans le firmware adéquat au framework.  
C'est l'une des deux attaques retrouvé dans le front-end: l'utilisateur peut commencer un scan qui notifiera le front-end lors de découvertes, puis l'arrêter quand bon lui semble. Les appareils et connexions répertoriées ainsi que leurs informations sont disponibles sur la colonne de droite (@fig:front-lists).

![Appareils et connexions repertoriées à proximité](img/lists.png){#fig:front-lists width=90%}

La carte BBC micro:bit n'intégrant qu'une puce nRF51, une seule commande peut être réalisée à la fois, Mirage met cependant en place du balayage de canaux basé sur un changement rapide de commandes directement dans le firmware via les minuteurs disponibles sur la carte. Ce balayage permet la découverte d'appareils BLE sur les canaux d'annonces 37, 38 et 39 avec une seul carte micro:bit.  
Le sniffing des connexions est peu fiable dû au changement impredictible de canaux imposé par le *channel hopping*. Cette mitigation intégrée au protocole BLE rend incertain le temps pour identifié une ou plusieurs connexions BLE, la carte micro:bit changeant elle aussi de canaux pour maximiser ces chances de trouver des connexions les utilisants.  

Cette attaque profite du caractère publique des canaux utilisés pour les communications, il est possible de mitiger son impact en rendant plus difficile l'identification des appareils par la réduction du nombre d'annonces émises et en choisissant le type d'annonce en fonction des besoins. Il n'est pas toujours necessaire d'emettre des annonces indirecte contenant des données du *GAP*, les annonces directes contiennent par exemple seulement le *central* recherché, rendant plus complexe la tache d'identification de l'appareil. Le *sniffing* des connexions peut egalement etre durcie en modifiant les parametres de connexion émis, plutot que d'utiliser une carte des canaux par defaut se basant sur les 37 canaux de donnees.

## Localisation

Il existe plusieurs moyens de localiser des appareils, la localisation interieur est d'ailleurs un champ de recherche complexe et tres actif allant de l'inventaire d'entrepots jusqu'au profilage publicitaire.  
Pour obtenir une estimation de la distance d'un appareil on peut se basé sur le temps que met l'onde a nous parvenir (appelé *Time Of Arrival* ou *TOA*) pour en deduire la distance a partir de sa vitesse. Cependant cela requiert une information fournie par l'emetteur: l'heure d'émission, en me placant en tant qu'attaquant je ne controle pas les appareils ciblés et ne peut pas garantir la presence de cette information car peu utilisée dans les appareils particuliers.  
Une autre methode beaucoup plus populaire et accessible se base sur le *RSSI* (*Received Signal Strength Indicator*). C'est un indicateur de la puissance du signal reçu en `dBm` duquel peut etre deduit la distance de l'emetteur. Cependant le BLE pouvant emettre sur une plage de puissances il est primoridial de connaitre ou trouver la puissance d'emission utilisée de la part de l'emetteur. Heureusement un standard a ete developpé pour les beacons, nommé iBeacon et intégré dans le *GAP* et le *GATT* en tant que *Tx Power* (puissance de transmission), il fourni une valeur de calibrage représentant la puissance mesurée par le constructeur a 1 metre. Meme si sa presence n'est pas garantie, le standard est tres répandu dans les appareils domestique et de bureautique.  
Les entrepots et centres commerciaux utilisent sur le *fingerprinting*, c'est a dire le positionnement par rapport a des appareils proche identifiés. Chaque appareil est répertorié avec sa position et son calibrage, l'objet a localiser applique ensuite une *trilateration* a partir de la position de 3 appareils a proximité. Cette solution n'est adaptée a mon besoin car elle demande la liste des appareils identifiés, information indisponible en tant qu'attaquant.

Ensuite viens une seconde problematique, le *TOA* et *RSSI* ne fournissent pas d'information sur la direction de l'appareil, seulement une distance. Il faut alors croiser plusieurs relevés avec de la trilatération, procedé au coeur du systeme GPS visant a trouver une intersection commune entre minimum 3 cercles (voir @fig:methodes-localisation), ou utiliser une matrice d'antennes pour calculer la direction du signal reçu.  
Le BLE intègre depuis la version 5.1 le mecanisme d'angles de départ et d'arrivée (*AOA*/*AOD*) permettant de trouver la direction a l'aide d'une matrice d'antennes en plus d'augmenter la precision de l'ordre du metre au centimetre. Chaque antenne recois le signal avec un decalage par rapport a ses voisines, ce decalage temporel est utilisé pour approximer l'angle d'emission. En utilisant cette technique, et a partir de plusieurs emetteurs, on peut determiner une position sans se baser sur le *RSSI* ou *TOA* mais en utilisant la *triangulation*.

Pour ma part, je travail sur la version 4.0 du protocole BLE, qui n'integre pas le mecanisme *AOA*/*AOD*. Meme si il est possible de mettre en place cette methode sans la version 5.1 du BLE, cela requiert une matrice d'antennes, materiel indisponible au vu des conditions exceptionnelles.  
J'ai opté pour le *RSSI* au vu de la popularité et facilité de mise en place de la methode. Les relevés sont fortement impactés par l'environnement, l'etude de celui-ci et la mise en place de modeles etant impossible dans mon cas, j'ai fixé le facteur environnmental en tant qu'espace dégagé. Je laisse tout de meme la possibilite a l'utilisateur de modifier ce facteur si besoin. Le second facteur est la sensibilité de reception, la puce nRF51 garantie une valeur à plus ou moins 6dBm avec un seuil de -30 a -90dBm, mon but est donc de reduire l'impact des ecarts de releves.

Pour les appareils en mouvement on peut ajouter de la precision avec le *dead-reckoning*, permettant de faire des previsions de position a partir de celle actuelle et des capteurs intégrés a l'appareil (gyroscope, accelerometre). On retrouve ce mecanisme pour les appareils ou applications GPS, tirant avantage des capteurs integres dans nos smartphones. Des modeles mathematiques comme le filtre de Kalman permettent egalement d'approximé les prochaines valeurs.

Le fait de se placer en tant qu'attaquant donc de ne pas controller les appareils rend le *dead-reckoning* inutilisable. 
J'ai choisit le modèle de pertes le plus frequement utilisé pour le *RSSI* car un modele de pertes personnalisé pour un environnement donné n'est pas envisageable puisque le projet est fait pour de la sensibilisation et est donc amené a en changer frequement.  
Dans le but de reduire les ecarts, j'ai commencé par un lissage des valeurs sur une fenetre modifiable. Cela me permet de confirmer une tendance, minimisant l'impact des fluctuations du *RSSI*. Le filtre de Kalman semble etre une amelioration interessante et pourrait etre une prochaine etape.

### Intégration

Dans Mirage, la localisation se base sur le travail d'identification precedement realisé par la phase de scan. Le firmware Mirage integre des informations relevees depuis la puce `nRF51` sur la transmission reçu comme la puissance du signal (*Received Signal Strength Indicator* ou *RSSI*). A partir de cette information ainsi qu'un calibrage (`TxPower`) il est possible d'approximer la distance avec le modele de pertes suivant:

$$distance = 10^{(TxPower - RSSI) / (10 * n)}$$

Ou `n` est le facteur environnemental variant de 2 (espace dégagé) à 4 (zone urbaine).

Les fonctionnalités de localisation ont etes integres en tirant profit des possibilites d'extensiblité de Mirage avec l'integration d'un nouveau module: `ble_locate`. Le module partage beaucoup de fonctionnalités avec `ble_sniff`, permetttant le scan des appareils et connexions a promixité et modifie l'API de BTLEJack au sein de Mirage pour faciliter le scan de connexions. Mon but etait de faire avec ce qui etait integre au firmware Mirage car sa recompilation demande la mise en place d'un environnement precis[@yotta]. Le module se conforme aux codes de Mirage et pourrait etre fusionné au sein du framework comme fonctionnalité supplémentaire a l'avenir.  
Concernant l'interface, une carte permet de se faire une idée de la distance des appareils localisés. La carte à une échelle relative a l'appareil le plus eloigné car le BLE a une portee d'emission d'environ 10 metres, ce qui renderait indistinctibles les appareils proches si la carte couvrait toute la zone d'emission. Les autres appareils sont mis a l'echelle relativement par rapport au plus eloigné pour garder une representation realiste.

![Carte des appareils localisés](img/radar.png){#fig:radar width=50%}

Cette attaque concerne cependant seulement les appareils implemetant le standard iBeacon. D'une facon plus generale l'attaque est facilement mitigable en ne transmettant pas d'indication de distance dans le *GAP*, l'exposant uniquement dans le *GATT* une fois le *central* identifié. Même si les beacons sont forcés d'inclure ses indications dans le *GAP*, ils ne sont pas concernés par la plupart des attaques car non connectables.

## MITM

C'est une des attaques fournies par Mirage, implemetee dans le module `ble_mitm`. Cette attaque ne se base pas sur un sniffer pour intercepter du traffic et extraire des informations mais deux dongles BLE `CSR8510` pour occuper et usurper le *peripheral* ciblé puis profiter du manque d'authentification et un chiffrement peu robuste dans la méthode d'appairage `JustWorks`.  
L'attaque requiert que le *peripheral* ciblé ne soit pas connecté pour pouvoir usurper son identité et s'annoncer a sa place. Meme si il est auparavant possible de forcer une deconnexion des appareils via du brouillage (principe utilisé dans le *hijacking*), l'attaque echoue si une session (*LTK*) a ete mise en place car celle-ci à besoin des parametres echanges au moment de l'appairage pour casser le chiffrement.  
L'attaque requiert egalement qu'un *central* se connecte au *peripheral* usurpé, après quoi l'attaquant est en position de *man-in-the-middle*, redirigeant le traffic d'un appareil à l'autre en utilisant les deux dongles CSR8510.  
Cette attaque fonctionne autant sur des appareils utilisant la connexion comme l'appairage avec la methode `JustWorks` car le chiffrement peut etre facilement cassé avec l'outil *Crackle*[@crackle], implementé par le module `ble_crack` dans Mirage, qui permet de trouver la clef de chiffrement a partir des information echangées lors de l'appairage.

Les attaques *MITM* sont une problematique repandue dans les communication donc nombres de contre-mesures sont disponibles dans les protocoles réseau. Le BLE fournie d'autres methodes d'appairage permettant d'authentifier la connexion et certains appareils restreignent les droits ou refusent les connexions ne se conformant pas a leurs exigences.

## Hijack

Peut être vu comme une version plus versatile du *MITM* puisque l'attaque peut fonctionner sur une connexion pre-etablie. 
L'attaque a cependant une vocation uniquement offensive, ne permettant pas la rétro-ingénierie par l'etude des communication echangées. Elle peut etre vue comme un *MITM* ou l'on ne relayerait pas les paquets entre *peripheral* et *central* mais forgerais nos propres paquets pour discuter avec le *central*. 

Contrairement au *MITM* qui relaye les communications logiciellement au sein de Mirage entre deux CSR8510, cette attaque utilise un sniffer `micro:bit` pour se synchroniser puis detourner une communication.  
La premiere phase de synchronisation a deux modes de fonctionnement suivant les besoins: le premier cible des appareils ayant l'intention de se connecter, Mirage intercepte les requetes de connexion emises sur les canaux d'annonces pour se synchroniser avec la connexion fraichement créée. Le second essaye de retrouver les parametres de connexions d'une connexion etablie afin de s'y synchroniser.  
Dans les deux cas il est necessaire de connaitre les parametres echanges a la connexion pour se synchroniser (carte des canaux ainsi que le nombre et temps entre chaque saut), seule la methode d'obtention diffère.

Je m'interesse a la seconde methode car je propose cette attaque sur des connexion etablies auparavant répertoriées via *sniffing*.  
La récupération des parametres de connexion est peu reliable dû au saut de fréquence utilisé par le protocole pour éviter les interferences. La `micro:bit` change de canal frequement pour augmenter ces chances d'en trouver un utilisé mais il en va de meme pour les connexion. C'est le jeu du chat et de la souris et ce n'est qu'une question de temps et de chance avant que la carte découvre tout les canaux utilisés.
Le second point noir de cette attaque est qu'elle est inutile si la connexion est chiffrée, vu que l'on se synchronise bien après la phase d'appairage (a moins d'etre tres chanceux). Le chiffrement est alors deja etablie et incassable, et meme si il reste possible de detourner la connexion on ne pourra rien en faire car incapable de communiquer avec l'autre appareil.

L'attaque est disponible nativement dans Mirage avec le module `ble_hijack`, fortement lié au module `ble_sniff` pour se synchroniser a une connexion etablie. Ne disposant pas d'assez d'elements pour casser le chiffrement d'une connexion etablie, le détournement cible les appareils n'en utilisant pas comme des capteurs/actionneurs industriels ou domotique. 

## Tests et validation

Dû aux conditions exceptionnelles imposees par le confinement, je n'avait pas de materiel BLE candide a disposition pour realiser mes attaques. J'ai donc mis en place un reseau de test predictible et factice entre deux `CSR8510` a l'aide des modules imittant un *peripheral* (`ble_slave`) et son *central* (`ble_master`). Grace aux scenarios Mirage j'ai pu modifier leurs fonctionnement pour mettre en place un scenario de test reproductible qui m'a grandement aidé pour identifier et corriger les *bugs* lors des développements.
Il semble cependant complexe d'automatiser le test de toutes les attaques implementées puisque incertaines. Les tests unitaires de code donnent un resultat attendu et identique en un temps donné, maintenant tester le réseau est beaucoup plus incertain car instable. Les attaques peuvent ne jamais se déclencher ou des interferences peuvent interrompre le deroulement.  
Des tests sur le scan, la localisation, l'usurpation (*MITM*) et le détournement (*hijack*) sont tout de meme realisable manuellement via le CLI Mirage.  

Le scan requiert un dongle CSR8510 emettant des annonces (voir plusieurs) et minimum une connexion etablie. Le scenario `MockSlave` (modiciation du module `ble_slave` a des fins de test) s'annonce jusqu'a ce qu'une connexion soit faite, permettant de tester le scan d'appareils alentours. Quant aux connexions etablies cela requiert une pair de `MockSlave` et `MockMaster` avec leurs CSR8510 respectifs: les scenarios de test emettent des requetes preiodiquement une fois connecté pour generer un traffic.  
Comme évoqué precedemment, le scan des connexions etablie est incertain et peut durer indéfiniement. On pourrait mitiger ce probleme en parrallelisant plusieurs `micro:bit`, chacune scannant une partie des 37 canaux de données. Dans l'ideal il faudrait 37 micro:bit pour les canaux de données et 3 pour ceux d'annonces. Mirage dispose d'ailleurs du balayage pour pallier a ce probleme de parralelisation lors du scan d'appareils.

Les `MockSlave` sont programmés pour emettre `TxPower` dans leur annonce pour permettre la localisation, calibrage precedemment relevé a 1 metre du CSR8510 puis intégré au *GAP*. On ainsi peut mesurer l'acuité des distances en les comparants a la realité. Apres avoir fait plusieurs tests a des distance variant de moins d'un metre a 10 metres, le RSSI est fortement affecté par la distance et les objets entre l'emetteur et le recepteur. A une distance de moins d'un metre on trouve un resultat avec une precision de l'ordre de 30 centimetre et si l'on se place hors de la ligne de vue de l'emetteur, la distance calculée augmente car le RSSI diminue dû aux pertes. Un autre probleme est le seuil de sensibilité annoncé de -30 a -90dBm par le constructeur de la puce nRF51 mais d'apres mes test (basés sur le firmware Mirage) celui-ci varie entre -45dBm au plus proche jusqu'a -70dBm a la distance maximale hors de la ligne de vue (apres quoi le signal est considéré perdu). La precision des resultats aux bornes de ces valeurs est faussée car un appareil se trouvant a 10 comme a 45 centimetres aura un RSSI de -45dBm, idem pour un appareil proche de la distance maximale de reception.  
Une amélioration intéressante serait l'ajout de points de releves pour permettre la triangulation a partir d'un seul recepteur. Il suffierait des lors de se deplacer entre chaque releve pour avoir une idée des appareils localisés dans l'espace, et non seulement une distance. Bien sur il est possible d'ajouter 2 autres RaspberryPi avec leurs micro:bit pour permettre une triangulation a partir d'un seul releve, en admettant qu'elles soient disposees correctement.

L'usurpation demande 2 `CSR8510` pour mener l'attaque et 2 pour la testée ainsi qu'un ordre précis dans l'execution. Un dongle CSR8510 ecoute les annonces dans l'attente du `MockSlave`. Une fois trouvé, il s'y connecte, le clone et maintient la connexion pour stopper l'emission d'annonces. Un second CSR8510 usurpe le `MockSlave` precedemment cloné et s'annonce en tant que tel dans l'attente du `MockMaster`. Des lors que le `MockMaster` se connecte a l'usurpateur, un scenario modifie les paquets échangés entre `MockSlave` et `MockMaster`, rendant vérifiable le fonctionnement de l'attaque depuis leurs CLI respectifs. 

Le détournement de connexion est testé contre une connexion factice sans appairage entre un `MockSlave` et un `MockMaster`. Avec une seule `micro:bit`, le *sniffing* de la connexion était deja tres long pour esperer tomber sur les canaux utilisés par une seule connexion. La recuperation des parametres de connexion n'a jamais reussie, meme dans un delais assez long.  
`BTLEJack` et `Mirage` mettent d'ailleurs en garde sur la reliabilité de cette attaque et est plus considere comme experimentale qu'utile pour le *pentest*.  Il semble obligatoire de parralleliser l'analyse des canaux de donnees afin d'augmenter leur couverture pour esperer conduire l'attaque voir reduire le temps necessaire a cette phase.