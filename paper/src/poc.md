```{=latex}
\clearpage
```

# Travail réalisé

## Scan

Le *scan* des appareils et le *sniffing* des connexions BLE alentours se base sur un *sniffer* `BLE`: la carte `micro:bit` dans mon cas. Les fonctionnalités de *scan* sont nativement supportées par `Mirage` et intégrées dans le firmware adéquat au framework.  
C'est l'une des deux attaques retrouvées dans le *front-end*: l'utilisateur peut commencer un *scan* qui notifiera le *front-end* lors de découvertes, puis l'arrêter quand bon lui semble. Les appareils et connexions répertoriées ainsi que leurs informations sont disponibles sur la colonne de droite (@fig:front-lists).

![Appareils et connexions repertoriées à proximité](img/lists.png){#fig:front-lists width=100%}

La carte `micro:bit` n'intégrant qu'une puce `nRF51`, une seule commande peut être réalisée à la fois. `Mirage` met cependant en place du balayage de canaux basé sur un changement rapide de commandes directement dans le *firmware* via les minuteurs disponibles sur la carte. Ce balayage permet la découverte d'appareils `BLE` sur les canaux d'annonces 37, 38 et 39 avec une seul carte `micro:bit`.  
Le sniffing des connexions est peu fiable dû au changement imprédictible de canaux imposé par le *channel hopping*. Cette mitigation intégrée au protocole `BLE` rend incertain le temps pour identifier une ou plusieurs connexions `BLE`, la carte `micro:bit` changeant elle aussi de canaux pour maximiser ces chances de trouver des connexions les utilisants.  

Cette attaque profite du caractère publique des canaux utilisés pour les communications, il est possible de mitiger son impact en rendant plus difficile l'identification des appareils par la réduction du nombre d'annonces émises et en choisissant le type d'annonce en fonction des besoins. Il n'est pas toujours nécessaire d'émettre des annonces indirecte contenant des données du *GAP*, les annonces directes contiennent par exemple seulement le *central* recherché, rendant plus complexe la tàche d'identification de l'appareil. Le *sniffing* des connexions peut également être durci en modifiant les paramètres de connexion émis plutôt que d'utiliser une carte des canaux par défaut se basant sur les 37 canaux de données.

## Localisation

Il existe plusieurs moyens de localiser des appareils (@fig:ips-methods), la localisation intérieur est d'ailleurs un champ de recherche complexe et très actif allant de l'inventaire d'entrepots jusqu'au profilage publicitaire.  
Pour obtenir une estimation de la distance d'un appareil on peut se basé sur le temps que met l'onde à nous parvenir (appelé *Time Of Arrival* ou *TOA*) pour en déduire la distance à partir de sa vitesse. Cependant cela requiert une information fournie par l'émetteur: l'heure d'émission. En me placant en tant qu'attaquant je ne controle pas les appareils ciblés et ne peut pas garantir la présence de cette information car peu utilisée dans les appareils particuliers.  
Une autre méthode beaucoup plus populaire et accessible se base sur le *RSSI* (*Received Signal Strength Indicator*). C'est un indicateur de la puissance du signal reçu en `dBm` duquel peut être déduit la distance de l'émetteur. Cependant, le `BLE` pouvant émettre sur une plage de puissances, il est primoridial de connaître ou trouver la puissance d'émission utilisée de la part de l'émetteur. Heureusement un standard à été développé pour les balises, nommé *iBeacon* et intégré dans le *GAP* et le *GATT* en tant que *Tx Power* (puissance de transmission). Il fourni une valeur de calibrage qui représentative de la puissance mesurée par le constructeur à 1 mètre. Même si sa présence n'est pas garantie, le standard est très répandu dans les appareils domestique et de bureautique.  
Les entrepots et centres commerciaux utilisent le *fingerprinting*, c'est à dire le positionnement par rapport a des appareils proches identifiés. Chaque appareil est répertorié avec sa position et son calibrage, l'objet à localiser applique ensuite une *trilatération* (@fig:ips-methods) à partir de la position de 3 appareils à proximité. Cette solution n'est adaptée à mon besoin car elle demande la liste des appareils identifiés, information indisponible en tant qu'attaquant.

Ensuite viens une seconde problématique, le *TOA* et *RSSI* ne fournissent pas d'information sur la direction de l'appareil, seulement une distance. Il faut alors croiser plusieurs relevés avec de la *trilatération*, procedé au coeur du système GPS visant a trouver une intersection commune entre minimum 3 cercles (voir @fig:ips-methods), ou utiliser une matrice d'antennes pour calculer la direction du signal reçu.  
Le `BLE` intègre depuis la version 5.1 un mécanisme d'angles de départ et d'arrivée (*AOA*/*AOD*) permettant de trouver la direction à l'aide d'une matrice d'antennes en plus d'augmenter la précision de l'ordre du mètre au centimètre. Chaque antenne reçois le signal avec un décalage par rapport à ses voisines, ce décalage temporel est utilisé pour approximer l'angle d'émission. En utilisant cette technique, et à partir de plusieurs émetteurs, on peut determiner une position sans utiliser le *RSSI* ou *TOA* mais en utilisant la *triangulation* (@fig:ips-methods).

![Différentes méthodes pour la localisation intérieur](img/ips-methods.png){#fig:ips-methods width=80%}

Pour ma part, je travail sur la version 4.0 du protocole `BLE`, qui n'intègre pas le mécanisme *AOA*/*AOD*. Même si il reste possible de mettre en place cette methode sans la version 5.1 du protocole, cela requiert une matrice d'antennes, matériel indisponible au vu des conditions exceptionnelles.  
J'ai opté pour le *RSSI* au vu de la popularité et facilité de mise en place de la méthode. Les relevés sont fortement impactés par l'environnement, l'étude de celui-ci et la mise en place de modèles apadtés étant impossible dans mon cas, j'ai fixé le facteur environnmental en tant qu'espace dégagé. Je laisse tout de même la possibilité à l'utilisateur de modifier ce facteur si besoin. Le second facteur est la sensibilité de réception, la puce `nRF51` garantie une valeur à plus ou moins 6dBm avec un seuil de -30 a -90dBm, mon but est donc de réduire l'impact des ces écarts.

Pour les appareils en mouvement on peut ajouter de la précision avec le *dead-reckoning*, permettant de faire des prévisions de position à partir de celle actuelle et des capteurs intégrés à l'appareil (gyroscope, accéléromètre). On retrouve ce mécanisme pour les appareils ou applications *GPS*, tirant avantage des capteurs intégrés dans nos smartphones. Des modèles mathématiques comme le filtre de *Kalman* permettent également d'approximé les prochaines valeurs.

Le fait de se placer en tant qu'attaquant donc de ne pas controller les appareils rend le *dead-reckoning* inutilisable. 
J'ai choisit le modèle de pertes le plus fréquement utilisé pour le *RSSI* puisque un modèle de pertes personnalisé pour un environnement donné n'est pas envisageable car le projet est fait pour de la sensibilisation et est donc amené à en changer frequement.  
Dans le but de réduire les écarts, j'ai commencé par un lissage des valeurs sur une fenêtre modifiable. Cela me permet de confirmer une tendance, minimisant l'impact des fluctuations du *RSSI*. Le filtre de *Kalman* semble être une amélioration intéressante et pourrait être une prochaine étape.

### Intégration

Dans `Mirage`, la localisation se base sur le travail d'identification précédement réalisé par la phase de *scan*. Le *firmware* `Mirage` intègre des informations relevées depuis la puce `nRF51` sur la transmission reçue comme la puissance du signal (*Received Signal Strength Indicator* ou *RSSI*). À partir de cette information ainsi qu'un calibrage (`TxPower`) il est possible d'approximer la distance avec le modèle de pertes suivant:

$$distance = 10^{(TxPower - RSSI) / (10 * n)}$$

Ou `n` est le facteur environnemental variant de 2 (espace dégagé) à 4 (zone urbaine).

Les fonctionnalités de localisation ont été intégrées en tirant profit des possibilités d'extensiblité de `Mirage` avec l'ajout d'un nouveau module: `ble_locate`. Le module partage beaucoup de fonctionnalités avec `ble_sniff`, permetttant le *scan* des appareils et connexions à promixité mais modifie l'*API* de `BTLEJack` au sein de `Mirage` pour faciliter le *sniff* de connexions. Mon but était de faire avec ce qui était intégré au *firmware* `Mirage` car sa recompilation demande la mise en place d'un environnement précis[@yotta]. Le module se conforme aux codes de `Mirage` et pourrait être fusionné au sein du *framework* comme fonctionnalité supplémentaire à l'avenir.  
Concernant l'interface, une carte permet de se faire une idée de la distance des appareils localisés. La carte a une échelle relative à l'appareil le plus éloigné car le `BLE` à une portée d'émission d'environ 10 mètres, ce qui renderait indistinctibles les appareils proches si la carte couvrait toute la zone d'émission. Les autres appareils sont mis à l'échelle relativement par rapport au plus éloigné pour garder une représentation réaliste.

![Carte des appareils localisés](img/radar.png){#fig:radar width=50%}

Cette attaque concerne cependant seulement les appareils qui implémentent le standard *iBeacon*. D'une façon plus générale l'attaque est facilement mitigable en ne transmettant pas d'indication de distance dans le *GAP*, l'exposant uniquement dans le *GATT* une fois le *central* identifié. Même si les balises sont forcées d'inclure ses indications dans le *GAP*, ils ne sont pas concernés par la plupart des attaques car non connectables.

## MITM

C'est une des attaques fournies par `Mirage`, implémentée dans le module `ble_mitm`. Cette attaque ne se base pas sur un *sniffer* pour intercepter du traffic et extraire des informations mais deux dongles `BLE` `CSR8510` pour occuper et usurper le *peripheral* ciblé puis profiter du manque d'authentification et un chiffrement peu robuste dans la méthode d'appairage `JustWorks`.  
L'attaque requiert que le *peripheral* ciblé ne soit pas connecté pour pouvoir usurper son identité et s'annoncer à sa place. Même si il est auparavant possible de forcer une déconnexion des appareils via du brouillage (principe utilisé dans le *hijacking*), l'attaque échoue si une session (*LTK*) à été mise en place car celle-ci à besoin des paramètres échangés au moment de l'appairage pour casser le chiffrement.  
L'attaque requiert également qu'un *central* se connecte au *peripheral* usurpé, après quoi il est en position de *man-in-the-middle*, redirigeant le traffic d'un appareil à l'autre en utilisant les deux dongles `CSR8510`.  
Cette attaque fonctionne autant sur des appareils qui connectés comme appairés avec la méthode `JustWorks` car le chiffrement peut être facilement brisé avec l'outil *Crackle*[@crackle], implémenté par le module `ble_crack` dans `Mirage`, qui permet de trouver la clef de chiffrement à partir des information échangées lors de l'appairage.

Les attaques *MITM* sont une problématique répandue dans les communication donc nombres de contre-mesures sont disponibles dans les protocoles réseau. Le `BLE` fournie d'autres méthodes d'appairage permettant d'authentifier la connexion et certains appareils restreignent les droits ou refusent les connexions qui ne se conforment pas à leurs exigences.

## Hijack

Le *hijack* peut être vu comme une version plus versatile du *MITM* puisque l'attaque peut fonctionner sur une connexion pré-établie. 
L'attaque à cependant une vocation uniquement offensive, elle ne permet pas la rétro-ingénierie par l'étude des communication échangées. Elle peut être vue comme un *MITM* ou l'on ne relaye pas les paquets entre *peripheral* et *central* mais forgeons nos propres paquets pour discuter avec le *central*. 

Contrairement au *MITM* qui relaye les communications logiciellement au sein de `Mirage` entre deux `CSR8510`, cette attaque utilise un sniffer `micro:bit` pour se synchroniser puis détourner une communication.  
La première phase de synchronisation à deux modes de fonctionnement suivant les besoins: le premier cible des appareils ayant l'intention de se connecter, `Mirage` intercepte les requêtes de connexion émises sur les canaux d'annonces pour se synchroniser avec la connexion fraichement créée. Le second essaye de retrouver les paramètres de connexions d'une connexion établie afin de s'y synchroniser.  
Dans les deux cas il est nécessaire de connaître les paramètres échangés à la connexion pour se synchroniser (carte des canaux ainsi que le nombre et temps entre chaque saut), seule la méthode d'obtention diffère.

Je m'intéresse à la seconde méthode car je propose cette attaque sur des connexion établies, auparavant répertoriées via *sniffing*.  
La récupération des paramètres de connexion est peu reliable due au saut de fréquence utilisé par le protocole pour éviter les interférences. La `micro:bit` change de canal fréquement pour augmenter ces chances d'en trouver un utilisé, mais il en va de même pour les connexions. C'est le jeu du chat et de la souris et ce n'est qu'une question de temps et de chance avant que la carte découvre tout les canaux utilisés.
Le second point noir de cette attaque est qu'elle est inutile si la connexion est chiffrée: le chiffrement est dèjà établi et incassable vu que l'on se synchronise bien après la phase d'appairage. Il reste possible de détourner la connexion pour du déni de service, même si on sera incapable de communiquer avec l'autre appareil.

L'attaque est disponible nativement dans `Mirage` avec le module `ble_hijack`, fortement lié au module `ble_sniff` pour se synchroniser à une connexion établie. Ne disposant pas d'assez d'éléments pour casser le chiffrement d'une connexion établie, le détournement cible les appareils n'en utilisant pas comme des capteurs/actionneurs industriels ou domotique. 

## Tests et validation

Dû aux conditions exceptionnelles imposées par le confinement, je n'avait pas de produits `BLE` à disposition pour réaliser mes attaques. J'ai donc mis en place un réseau de test prédictible et factice entre deux `CSR8510` à l'aide des modules imittant un *peripheral* (`ble_slave`) et son *central* (`ble_master`). Grâce aux scénarios `Mirage` j'ai pu modifier leurs fonctionnement pour mettre en place un scénario de test reproductible qui m'a grandement aidé pour identifier et corriger les *bugs* lors des développements.
Il semble cependant complexe d'automatiser le test de toutes les attaques implementées puisque incertaines. Les tests unitaires de code donnent un résultat attendu et identique en un temps donné, maintenant tester le réseau est beaucoup plus incertain car instable. Les attaques peuvent ne jamais se déclencher ou des interférences peuvent interrompre le déroulement.  
Des tests sur le *scan*, la localisation, l'usurpation (*MITM*) et le détournement (*hijack*) sont tout de même réalisables manuellement via le *CLI* `Mirage`.  

Le *scan* requiert un dongle `CSR8510` émettant des annonces et minimum une connexion établie. Le scénario `MockSlave` (modification du module `ble_slave` à des fins de test) s'annonce jusqu'à ce qu'une connexion soit faite, permettant de tester le *scan* d'appareils alentours. Quant aux connexions établies, cela requiert une pair de `MockSlave` et `MockMaster` avec leurs `CSR8510` respectifs: les scénarios de test émettent des requêtes périodiquement une fois connectés pour générer un traffic.  
Comme évoqué precedemment, le *scan* des connexions établie est incertain et peut durer indéfiniement. On pourrait mitiger ce problème avec la parrallélisation de `micro:bit`, chacune scannant une partie des 37 canaux de données. Il faudrait 37 `micro:bit` dans l'idéal pour les canaux de données et 3 pour ceux d'annonces. `Mirage` dispose d'ailleurs du balayage pour pallier à ce probleme de parrallélisation lors du scan d'appareils.

Les `MockSlave` sont programmés pour émettre `TxPower` dans leurs annonces pour permettre la localisation (calibrage précédemment relevé à 1 mètre du `CSR8510` puis intégré au *GAP*). On peut ainsi mesurer l'acuité des distances en les comparants à la realité. Après avoir fait plusieurs tests à des distances variants de moins d'un mètre jusqu'à 10 mètres, le *RSSI* est fortement affecté par la distance et les objets entre l'émetteur et le récepteur. À une distance de moins d'un mètre on trouve un résultat avec une précision de l'ordre de 30 centimètres et si l'on se place hors de la ligne de vue de l'émetteur, la distance calculée augmente car le *RSSI* diminue dû aux pertes. Un autre problème est le seuil de sensibilité, annoncé de -30 a -90dBm par le constructeur, de la puce `nRF51`: celui-ci varie entre -45dBm au plus proche jusqu'à -70dBm à la distance maximale hors de la ligne de vue (après quoi le signal est considéré perdu). La précision des résultats aux bornes de ces valeurs est faussée car un appareil se trouvant à 10 comme à 45 centimètres aura un *RSSI* de -45dBm, idem pour un appareil proche de la distance maximale de réception.  
Une amélioration intéressante serait l'ajout de points de relevés pour permettre la triangulation à partir d'un seul récepteur. Il suffirait dès lors de se déplacer entre chaque relevé pour avoir une idée des appareils localisés dans l'espace, et plus seulement une distance. Bien sur il est possible d'ajouter 2 autres `RaspberryPi` avec leurs `micro:bit` pour permettre une triangulation à partir d'un seul relevé, en admettant qu'elles soient disposées correctement.

L'usurpation demande 2 `CSR8510` pour mener l'attaque et 2 pour la tester ainsi qu'un ordre précis dans l'exécution. Un dongle `CSR8510` écoute les annonces dans l'attente du `MockSlave`. Une fois trouvé, il s'y connecte, le clone et maintient la connexion pour stopper l'émission d'annonces. Un second `CSR8510` usurpe le `MockSlave` précédemment cloné et s'annonce en tant que tel dans l'attente du `MockMaster`. Dès lors que le `MockMaster` se connecte à l'usurpateur, un scénario modifie les paquets échangés entre `MockSlave` et `MockMaster`, rendant vérifiable le fonctionnement de l'attaque depuis leurs *CLI* respectifs. 

Le détournement de connexion est testé contre une connexion factice sans appairage entre un `MockSlave` et un `MockMaster`. Avec une seule `micro:bit`, le *sniffing* de la connexion était déjà très long pour espérer tomber sur les canaux utilisés par une seule connexion. La récuperation des paramètres de connexion n'a jamais réussie, même avec un long délai.  
`BTLEJack` et `Mirage` mettent d'ailleurs en garde sur la reliabilité de cette attaque et est plus considérée comme expérimentale qu'utile pour le *pentest*.  Il semble obligatoire de parralléliser l'analyse des canaux de données afin d'augmenter leur couverture pour espérer conduire l'attaque voir réduire le temps nécessaire à cette phase.